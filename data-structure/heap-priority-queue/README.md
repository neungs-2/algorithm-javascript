# **Heap and Priority Queue**

## **Priority Queue**

- 큐에 우선순위 개념을 도입한 자료구조
- 우선순위가 높은 데이터가 먼저 출력
- **우선순위 큐를 힙 자료구조**로 구현하는 것이 가장 효율적

|  자료구조   |          출력 요소          |
| :---------: | :-------------------------: |
|    스택     |  가장 최근에 들어온 데이터  |
|     큐      |   가장 먼저 들어온 데이터   |
| 우선순위 큐 | 가장 우선순위가 높은 데이터 |

|       구현 방법       |   삽입    | 삭제(출력) |
| :-------------------: | :-------: | :--------: |
|    순서 없는 배열     |   O(1)    |    O(n)    |
| 순서 없는 연결 리스트 |   O(1)    |    O(n)    |
|      정렬된 배열      |   O(n)    |    O(1)    |
|  정렬된 연결 리스트   |   O(n)    |    O(1)    |
|       힙(heap)        | O(*log*n) | O(*log*n)  |

<br>

**_이용사례_**

- 시뮬레이션 시스템
- 네트워크 트래픽 제어
- 운영 체제에서의 작업 스케쥴링
- 수치 해석적인 계산

---

<br>

## **Heap 자료구조**

- **완전 이진 트리**의 일종
- 여러 개의 값들 중 최대/최소 값을 빠르게 탐색
- 일종의 반정렬 상태(느슨한 정렬 상태) 유지
  - 큰 값이 상위, 작은 값이 하위 정도의 느슨함
- 힙 트리에서는 중복된 값을 허용

<br>

**_최대 힙(max heap)_**

- key(부모 노드) >= key(자식 노드)

**_최소 힙(min heap)_**

- key(부모 노드) <= key(자식 노드)

![image](https://user-images.githubusercontent.com/60606025/148164767-42ff05d1-c152-4d90-bf67-a1a14847f6f4.png)

<br>

**_부모 노드와 자식 노드의 관계_**

- 왼쪽 자식의 인덱스 = (부모의 인덱스) \* 2 + 1
- 오른쪽 자식의 인덱스 = (부모의 인덱스) \* 2 + 2
- 부모의 인덱스 = (자식의 인덱스 - 1 ) / 2 --> (몫)

그림의 인덱스는 - 1 해줘야 함. (잘못된 그림)

![image](https://user-images.githubusercontent.com/60606025/148167489-6ff76eac-dfdb-45fe-8754-d39cbde3f14c.png)
